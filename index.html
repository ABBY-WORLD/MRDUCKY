<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Sidescrolling Anka</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Spelvariabler
    const groundHeight = 100;
    let gameSpeed = 3;
    let worldX = 0; // Totala scrollningen i världen
    let score = 0;
    let rocks = [];
    // Timer för när nästa sten ska spawnas (i frames)
    let rockSpawnTimer = Math.floor(Math.random() * 150) + 150;

    // Ladda bilder
    const duckImage = new Image();
    duckImage.src = 'mrducky.png';
    duckImage.onload = () => console.log("MrDucky image loaded.");
    duckImage.onerror = () => console.error("Error loading mrducky.png");

    const backgroundImage = new Image();
    backgroundImage.src = 'map.jpg';
    backgroundImage.onload = () => console.log("Map image loaded.");
    backgroundImage.onerror = () => console.error("Error loading map.jpg");

    // Ny bana - byts in när poängen når 3000
    const backgroundImage2 = new Image();
    backgroundImage2.src = 'map2.jpg';
    backgroundImage2.onload = () => console.log("Map2 image loaded.");
    backgroundImage2.onerror = () => console.error("Error loading map2.jpg");

    const rockImage = new Image();
    rockImage.src = 'rock.png';
    rockImage.onload = () => console.log("Rock image loaded.");
    rockImage.onerror = () => console.error("Error loading rock.png");

    // Ladda och spela bakgrundsmusiken
    const music = new Audio('mrducky.mp3');
    music.loop = true;
    music.volume = 0.5;
    music.play().catch(error => {
      console.warn("Autoplay blockerades. Klicka för att starta musiken.", error);
    });
    document.addEventListener('click', () => { if(music.paused) music.play(); });

    // Anka-objektet med justerade hoppparametrar
    const duck = {
      x: 100,
      y: canvas.height - groundHeight - 50, // Ankan är 50px hög
      width: 50,
      height: 50,
      vy: 0,
      gravity: 1.0,      // Lägre gravitation för längre lufttid
      jumpForce: -28,    // Starkare hoppkraft för högre hopp
      isJumping: false
    };

    // Tangentlyssnare för hopp
    document.addEventListener('keydown', e => {
      if(e.code === 'Space' || e.keyCode === 32) {
        if (!duck.isJumping) {
          duck.vy = duck.jumpForce;
          duck.isJumping = true;
        }
      }
    });

    // Rita bakgrunden med två kopior, baserat på worldX.
    // Om score >= 3000 används backgroundImage2 istället för backgroundImage.
    function drawBackground() {
      const currentBg = (score >= 3000) ? backgroundImage2 : backgroundImage;
      let bgX = worldX % canvas.width;
      bgX = -bgX;
      ctx.drawImage(currentBg, bgX, 0, canvas.width, canvas.height);
      ctx.drawImage(currentBg, bgX + canvas.width, 0, canvas.width, canvas.height);
    }

    // Uppdatera ankan (gravitation och markkollision)
    function updateDuck() {
      duck.vy += duck.gravity;
      duck.y += duck.vy;
      if (duck.y + duck.height >= canvas.height - groundHeight) {
        duck.y = canvas.height - groundHeight - duck.height;
        duck.vy = 0;
        duck.isJumping = false;
      }
    }

    // Rita ankan
    function drawDuck() {
      if (duckImage.complete) {
        ctx.drawImage(duckImage, duck.x, duck.y, duck.width, duck.height);
      } else {
        ctx.fillStyle = 'yellow';
        ctx.fillRect(duck.x, duck.y, duck.width, duck.height);
      }
    }

    // Skapa en sten med en worldX-position
    function spawnRock() {
      const rockWidth = 40;
      const rockHeight = 40;
      const rock = {
        worldX: worldX + canvas.width + Math.random() * 200, // placera utanför skärmen
        y: canvas.height - groundHeight - rockHeight,
        width: rockWidth,
        height: rockHeight
      };
      rocks.push(rock);
    }

    // Uppdatera stenarna: behåll bara de som är synliga och hantera spawn-timer
    function updateRocks() {
      rocks = rocks.filter(rock => (rock.worldX - worldX + rock.width) > 0);
      if (rockSpawnTimer <= 0) {
        spawnRock();
        rockSpawnTimer = Math.floor(Math.random() * 150) + 150;
      } else {
        rockSpawnTimer--;
      }
    }

    // Rita stenarna
    function drawRocks() {
      rocks.forEach(rock => {
        let rockScreenX = rock.worldX - worldX;
        if (rockImage.complete) {
          ctx.drawImage(rockImage, rockScreenX, rock.y, rock.width, rock.height);
        } else {
          ctx.fillStyle = 'gray';
          ctx.fillRect(rockScreenX, rock.y, rock.width, rock.height);
        }
      });
    }

    // Enkel kollisionsdetektion (axis-aligned bounding box)
    function isColliding(a, rockScreenX, rock) {
      return a.x < rockScreenX + rock.width &&
             a.x + a.width > rockScreenX &&
             a.y < rock.y + rock.height &&
             a.y + a.height > rock.y;
    }

    // Återställ spelet vid kollision
    function resetGame() {
      score = 0;
      rocks = [];
      duck.y = canvas.height - groundHeight - duck.height;
      duck.vy = 0;
      duck.isJumping = false;
      worldX = 0;
      rockSpawnTimer = Math.floor(Math.random() * 150) + 150;
    }

    // Spelloopen
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Uppdatera världens scrollning
      worldX += gameSpeed;
      
      // Rita bakgrunden
      drawBackground();

      // Uppdatera och rita ankan
      updateDuck();
      drawDuck();

      // Uppdatera och rita stenarna
      updateRocks();
      drawRocks();

      // Kollisionskontroll
      for (let rock of rocks) {
        let rockScreenX = rock.worldX - worldX;
        if (isColliding(duck, rockScreenX, rock)) {
          resetGame();
          break;
        }
      }

      // Uppdatera poängen
      score++;
      ctx.font = "20px Arial";
      ctx.fillStyle = "black";
      ctx.fillText("Score: " + score, 10, 30);

      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
